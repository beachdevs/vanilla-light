<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: client.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { components } from '/components.js';

window.api_url = window.api_url || window.location.origin;

/**
 * Returns the first element matching a CSS selector.
 * @param {string} s
 * @returns {Element|null}
 */
export const $ = (s) => document.querySelector(s);
/**
 * Returns all elements matching a CSS selector.
 * @param {string} s
 * @returns {NodeListOf&lt;Element>}
 */
export const $$ = (s) => document.querySelectorAll(s);
/**
 * Returns the closest ancestor for the DevTools-selected element (`$0`).
 * @param {string} s
 * @returns {Element|null}
 */
export const $c = (s) => $0.closest(s);

const req = (method, key, body) =>
  fetch(`${window.api_url}/${key ? encodeURIComponent(key) : ''}`, {
    method,
    headers: {
      ...(localStorage.token ? { Authorization: `Bearer ${localStorage.token}` } : {}),
    },
    body: body instanceof Blob || typeof body === 'string' ? body : JSON.stringify(body),
    credentials: 'include', 
  });
const toJson = (r) => {
  const ct = (r.headers.get('content-type') || '').toLowerCase();
  if (!ct.includes('application/json')) {
    return r.text().then((t) => { 
      throw new Error('Server returned non-JSON (HTML?): ' + (t.slice(0, 60) || r.status)); 
    });
  }
  return r.json();
};

/**
 * @typedef {Object} FetchJsonOptions
 * @property {boolean} [nullOnError=false] Return null when response status is not OK.
 * @property {boolean} [includeStatus=false] Return `{ ok, data }` instead of parsed JSON.
 */

/**
 * Makes an HTTP request and parses a JSON response.
 * @param {string} url
 * @param {any} [data]
 * @param {string} [method='POST']
 * @param {FetchJsonOptions} [options={}]
 * @returns {Promise&lt;any|{ok: boolean, data: any}|null>}
 */
export const fetchJson = async (url, data, method = 'POST', options = {}) => {
  const { nullOnError = false, includeStatus = false } = options;
  const r = await fetch(url, { 
    method,
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json',
      ...(localStorage.token ? { Authorization: `Bearer ${localStorage.token}` } : {}),
    },
    body: JSON.stringify(data)
  });
  if (!r.ok &amp;&amp; nullOnError) return null;
  const parsed = await toJson(r);
  if (includeStatus) {
    return { ok: r.ok, data: parsed };
  }
  return parsed;
};

/**
 * Fetches a JSON value by key.
 * @param {string} k
 * @returns {Promise&lt;any>}
 */
export const get = (k) => req('GET', k).then(toJson);
/**
 * Stores a JSON value by key.
 * @param {string} k
 * @param {any} v
 * @returns {Promise&lt;any>}
 */
export const set = (k, v) => req('POST', k, typeof v === 'string' ? JSON.stringify(v) : v).then(toJson);
/**
 * Uploads binary or text content by key.
 * @param {string} k
 * @param {Blob|string|ArrayBuffer|any} v
 * @returns {Promise&lt;any>}
 */
export const put = (k, v) => req('PUT', k, v).then(toJson);
/**
 * Deletes a key.
 * @param {string} k
 * @returns {Promise&lt;any>}
 */
export const del = (k) => req('DELETE', k).then(toJson);
/**
 * Purges a key from storage.
 * @param {string} k
 * @returns {Promise&lt;any>}
 */
export const purge = (k) => req('PURGE', k).then(toJson);
/**
 * Lists storage keys.
 * @returns {Promise&lt;any>}
 */
export const list = () => req('PROPFIND').then(toJson);
/**
 * Returns current authenticated user or null.
 * @returns {Promise&lt;any|null>}
 */
export const me = () => fetchJson(`${window.api_url}/me`, undefined, 'GET', { nullOnError: true });
/**
 * Starts Auth0 login flow.
 * @returns {void}
 */
export const loginAuth0 = () => {
  window.location.href = `${window.api_url}/login`;
};

/**
 * Registers a bearer-auth user and stores token when returned.
 * @param {string} email
 * @param {string} name
 * @param {string} sub
 * @returns {Promise&lt;any>}
 */
export const registerBearer = async (email, name, sub) => {
    const { ok, data } = await fetchJson(
      `${window.api_url}/register`,
      { email, name, sub },
      'POST',
      { includeStatus: true }
    );
    if (ok &amp;&amp; data?.token) localStorage.token = data.token;
    return data;
  };

/**
 * Logs in a bearer-auth user and stores token when returned.
 * @param {string} sub
 * @returns {Promise&lt;any>}
 */
export const loginBearer = async (sub) => {
    const { ok, data } = await fetchJson(
      `${window.api_url}/login`,
      { sub },
      'POST',
      { includeStatus: true }
    );
    if (ok &amp;&amp; data?.token) localStorage.token = data.token;
    return data;
  };

/**
 * Alias for `loginAuth0`.
 * @returns {void}
 */
export const login = () => loginAuth0();

/**
 * Starts Auth0 logout flow.
 * @returns {void}
 */
export const logoutAuth0 = () => {
  window.location.href = `${window.api_url}/logout`;
};

/**
 * Logs out bearer-auth user and clears local token.
 * @returns {Promise&lt;any|null>}
 */
export const logoutBearer = async () => {
    const t = localStorage.token;
    if (!t) return null;
    const r = await fetchJson(`${window.api_url}/logout`, undefined, 'GET', { nullOnError: true }).catch(() => null);
    delete localStorage.token;
    return r;
  };

/**
 * Logs out based on active auth mode.
 * @returns {Promise&lt;void>}
 */
export const logout = async () => {
    const t = localStorage.token;
    if (t) {
      await logoutBearer();
      return;
    }
    logoutAuth0();
  };

/**
 * Downloads a stored file by key.
 * @param {string} k
 * @returns {Promise&lt;void>}
 */
export const download = async (k) => {
    const r = await req('PATCH', k);
    if (!r.ok) throw new Error('Download failed');
    const a = document.createElement('a');
    a.href = URL.createObjectURL(await r.blob());
    a.download = k;
    a.click();
    URL.revokeObjectURL(a.href); 
  };

const componentRegistry = components &amp;&amp; typeof components === 'object' ? components : {};

const wireComponentActions = (root) => {
  root.querySelectorAll('[data-vl-action="download"]').forEach((btn) => {
    btn.addEventListener('click', async () => {
      const key = decodeURIComponent(btn.dataset.name || '');
      if (!key) return;
      await download(key);
    });
  });
  root.querySelectorAll('[data-vl-action="delete"]').forEach((btn) => {
    btn.addEventListener('click', async () => {
      const key = decodeURIComponent(btn.dataset.name || '');
      if (!key) return;
      await purge(key);
      location.reload();
    });
  });
  root.querySelectorAll('input[data-vl-action="upload"]').forEach((input) => {
    input.addEventListener('change', async () => {
      const f = input.files &amp;&amp; input.files[0];
      if (!f) return;
      await put(f.name, f);
      location.reload();
    });
  });
  root.querySelectorAll('[data-vl-action="login"]').forEach((btn) => {
    btn.addEventListener('click', () => {
      login();
    });
  });
};

const ren = async (el, v) => {
  const f = componentRegistry[el.tagName.toLowerCase()];
  if (f) {
    const dataAttr = el.getAttribute('data');
    const val = v !== undefined ? v : (dataAttr ? state[dataAttr] : undefined);
    try {
      if (f.render) {
        el.innerHTML = await f.render.call(f, val);
      } else if (typeof f === 'function') {
        el.innerHTML = await f(val);
      }
      wireComponentActions(el);
    } catch (e) {
      console.error(e);
    }
  }
};

/**
 * Reactive client state. Assigning `state[key]` re-renders `[data="key"]` nodes.
 * @type {Record&lt;string, any>}
 */
export const state = new Proxy({}, {
  set(o, p, v) {
    o[p] = v;
    $$(`[data="${p}"]`).forEach(el => ren(el, v));
    return true;
  }
});

/**
 * Renders all registered custom components currently in the DOM.
 * @returns {void}
 */
export const initComponents = () => {
    if (!document.body) return;
    Object.keys(componentRegistry).forEach((t) => {
      const elements = $$(t);
      if (elements.length > 0) {
        elements.forEach(el => ren(el));
      }
    });
  };

const boot = () => {
  initComponents();
  setTimeout(() => initComponents(), 10);
  if (document.body) {
    new MutationObserver((mutations) => {
      mutations.forEach((m) => {
        m.addedNodes.forEach((node) => {
          if (node.nodeType === 1) {
            const tag = node.tagName?.toLowerCase();
            if (tag &amp;&amp; componentRegistry[tag]) ren(node);
            node.querySelectorAll &amp;&amp; Array.from(node.querySelectorAll('*')).forEach((child) => {
              const childTag = child.tagName?.toLowerCase();
              if (childTag &amp;&amp; componentRegistry[childTag]) ren(child);
            });
          }
        });
      });
    }).observe(document.body, { childList: true, subtree: true });
  }
};
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', boot);
} else {
  setTimeout(boot, 0);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#$">$</a></li><li><a href="global.html#$$">$$</a></li><li><a href="global.html#$c">$c</a></li><li><a href="global.html#del">del</a></li><li><a href="global.html#download">download</a></li><li><a href="global.html#fetchJson">fetchJson</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#initComponents">initComponents</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#loginAuth0">loginAuth0</a></li><li><a href="global.html#loginBearer">loginBearer</a></li><li><a href="global.html#logout">logout</a></li><li><a href="global.html#logoutAuth0">logoutAuth0</a></li><li><a href="global.html#logoutBearer">logoutBearer</a></li><li><a href="global.html#me">me</a></li><li><a href="global.html#purge">purge</a></li><li><a href="global.html#put">put</a></li><li><a href="global.html#registerBearer">registerBearer</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#state">state</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Feb 17 2026 20:00:55 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
